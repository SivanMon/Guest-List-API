name: Build and Test API (Local DynamoDB, no AWS CLI)

on:
  push:
    branches: [ main, dev, staging, '*-feature' ]
  pull_request:
    branches: [ main, dev, staging ]

env:
  DOCKERHUB_USER: ${{ secrets.DOCKERHUB_USER }}
  DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
  IMAGE_NAME: guestlistapi

jobs:
  build-test-push:
    runs-on: ubuntu-latest

    services:
      dynamodb:
        image: amazon/dynamodb-local:latest
        ports:
          - 8000:8000
        options: >-
          --health-cmd="curl -s http://localhost:8000/shell/ || exit 0"
          --health-interval=5s --health-timeout=2s --health-retries=20

    # >>> Dummy creds + local config for ALL steps in this job <<<
    env:
      AWS_REGION: us-east-1
      DDB_ENDPOINT_URL: http://localhost:8000
      DDB_TABLE: guests-ci-${{ github.run_id }}
      AWS_ACCESS_KEY_ID: localtest
      AWS_SECRET_ACCESS_KEY: localtest
      AWS_SESSION_TOKEN: localtest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Setup Python (for small boto3 script)
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install runner-side deps
        run: |
          python -m pip install --upgrade pip
          pip install boto3

      - name: Create image tag
        id: tags
        shell: bash
        run: |
          BRANCH_NAME=${GITHUB_REF#refs/heads/}
          COMMIT_SHA=${GITHUB_SHA::7}
          DATE=$(date +%Y%m%d-%H%M%S)
          CLEAN_BRANCH=$(echo "$BRANCH_NAME" | sed 's/[^a-zA-Z0-9]/-/g')
          TAG="${CLEAN_BRANCH}-${DATE}-${COMMIT_SHA}"
          echo "tag=${TAG}" >> $GITHUB_OUTPUT
          echo "branch_name=${BRANCH_NAME}" >> $GITHUB_OUTPUT
          echo "clean_branch=${CLEAN_BRANCH}" >> $GITHUB_OUTPUT
          if [ "$BRANCH_NAME" = "main" ]; then
            echo "latest_tag=latest" >> $GITHUB_OUTPUT
          fi

      - name: Build Docker image (test tag)
        run: |
          docker build -t $DOCKERHUB_USER/$IMAGE_NAME:test .

      # ---- Create table in local DynamoDB via boto3 (no AWS CLI) ----
      - name: Create DynamoDB table (local via boto3)
        run: |
          python - <<'PY'
          import os, time
          import boto3
          region   = os.environ["AWS_REGION"]
          endpoint = os.environ["DDB_ENDPOINT_URL"]
          table    = os.environ["DDB_TABLE"]
          # Dummy creds come from env; that's enough for DynamoDB Local
          ddb = boto3.client("dynamodb", region_name=region, endpoint_url=endpoint)
          try:
              ddb.create_table(
                  TableName=table,
                  AttributeDefinitions=[{"AttributeName": "seq_num", "AttributeType": "S"}],
                  KeySchema=[{"AttributeName": "seq_num", "KeyType": "HASH"}],
                  BillingMode="PAY_PER_REQUEST",
              )
              print(f"Created table {table}")
          except ddb.exceptions.ResourceInUseException:
              print(f"Table {table} already exists")
          for _ in range(30):
              if ddb.describe_table(TableName=table)["Table"]["TableStatus"] in ("ACTIVE","UPDATING"):
                  break
              time.sleep(0.2)
          print("Table ready.")
          PY

      - name: Install jq
        run: |
          sudo apt-get update
          sudo apt-get install -y jq

      - name: Start API container (wired to local DynamoDB)
        run: |
          docker run -d \
            --name guestlist-test \
            --add-host=host.docker.internal:host-gateway \
            -p 1111:1111 \
            -e AWS_REGION="${AWS_REGION}" \
            -e DDB_TABLE="${DDB_TABLE}" \
            -e DDB_ENDPOINT_URL="http://host.docker.internal:8000" \
            -e AWS_ACCESS_KEY_ID="${AWS_ACCESS_KEY_ID}" \
            -e AWS_SECRET_ACCESS_KEY="${AWS_SECRET_ACCESS_KEY}" \
            -e AWS_SESSION_TOKEN="${AWS_SESSION_TOKEN}" \
            $DOCKERHUB_USER/$IMAGE_NAME:test

          echo "Waiting for app to start..."
          for i in {1..40}; do
            curl -fsS http://127.0.0.1:1111/health && break
            sleep 1
          done

          if ! curl -fsS http://127.0.0.1:1111/health >/dev/null; then
            echo "App did not become healthy in time:"
            docker logs guestlist-test
            exit 1
          fi

      - name: Check /api (debug)
        run: curl -fsS http://127.0.0.1:1111/api || true

      - name: Test GET /guests
        run: |
          code=$(curl -s -o /dev/null -w "%{http_code}" http://127.0.0.1:1111/guests)
          if [ "$code" = "200" ]; then
            echo "✓ GET /guests passed"
          else
            echo "✗ GET /guests failed (HTTP $code)"
            docker logs guestlist-test
            exit 1
          fi

      - name: Test POST /guests
        id: post
        run: |
          echo "Testing POST /guests..."
          TEST_ID="111111111"
          resp=$(curl -s -w "\n%{http_code}" -X POST http://127.0.0.1:1111/guests \
            -H "Content-Type: application/json" \
            -d '{
              "firstname": "CI",
              "surname": "Test",
              "quantity": "2",
              "phone": "0541234567",
              "email": "ci@test.com",
              "id": "'${TEST_ID}'"
            }')

          code=$(echo "$resp" | tail -1)
          body=$(echo "$resp" | head -n -1)

          if [ "$code" = "201" ] || [ "$code" = "200" ]; then
            echo "✓ POST /guests passed"
            seq_num=$(echo "$body" | jq -r '.guest.seq_num // empty')
            if [ -z "$seq_num" ] || [ "$seq_num" = "null" ]; then
              echo "Could not parse seq_num from response:"
              echo "$body"
              exit 1
            fi
            echo "seq_num=$seq_num" >> $GITHUB_OUTPUT
          else
            echo "✗ POST /guests failed (HTTP $code)"
            echo "Response: $body"
            docker logs guestlist-test
            exit 1
          fi

      - name: Test GET /guests/{id}
        run: |
          SEQ='${{ steps.post.outputs.seq_num }}'
          code=$(curl -s -o /dev/null -w "%{http_code}" "http://127.0.0.1:1111/guests/$SEQ")
          if [ "$code" = "200" ]; then
            echo "✓ GET /guests/$SEQ passed"
          else
            echo "✗ GET /guests/$SEQ failed (HTTP $code)"
            exit 1
          fi

      - name: Test DELETE /guests/{id}
        run: |
          SEQ='${{ steps.post.outputs.seq_num }}'
          code=$(curl -s -o /dev/null -w "%{http_code}" -X DELETE "http://127.0.0.1:1111/guests/$SEQ")
          if [ "$code" = "200" ] || [ "$code" = "204" ]; then
            echo "✓ DELETE /guests/$SEQ passed"
          else
            echo "✗ DELETE /guests/$SEQ failed (HTTP $code)"
            exit 1
          fi

      - name: Stop test container (always)
        if: always()
        run: |
          docker logs guestlist-test || true
          docker stop guestlist-test || true
          docker rm guestlist-test || true

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ env.DOCKERHUB_USER }}
          password: ${{ env.DOCKERHUB_TOKEN }}

      - name: Compute env tag
        id: envtag
        shell: bash
        run: |
          set -euo pipefail
          branch="${GITHUB_REF_NAME}"

          if [ "$branch" = "main" ]; then
            tag="latest"
          elif [ "$branch" = "staging" ]; then
            tag="staging"
          elif [ "$branch" = "dev" ]; then
            tag="dev"
          elif [[ "$branch" == *-feature* ]]; then
            tag="student-feature"
          else
            # fallback if someone creates a random branch
            tag="dev"
          fi

          echo "tag=${tag}" >> "$GITHUB_OUTPUT"

      - name: Push image to Docker Hub
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          tags: |
            ${{ env.DOCKERHUB_USER }}/${{ env.IMAGE_NAME }}:${{ steps.envtag.outputs.tag }}
            ${{ env.DOCKERHUB_USER }}/${{ env.IMAGE_NAME }}:${{ github.sha }}

          cache-from: type=gha
          cache-to: type=gha,mode=max

          provenance: mode=max
