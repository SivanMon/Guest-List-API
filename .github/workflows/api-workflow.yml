name: Build and Test API (Local DynamoDB)

on:
  workflow_dispatch:
    inputs:
      branch:
        description: 'Branch name to build/test'
        default: 'dev'
        type: choice
        required: true
        options: [sivan-feature, dvir-feature, gili-feature, sahar-feature, dev, main]
  push:
    branches: [ dev ]
  pull_request:
    branches: [ main ]

env:
  DOCKERHUB_USER: ${{ secrets.DOCKERHUB_USER }}
  DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
  IMAGE_NAME: guestlistapi

jobs:
  build-test-push:
    runs-on: ubuntu-latest

    services:
      dynamodb:
        image: amazon/dynamodb-local:latest
        ports:
          - 8000:8000
        options: >-
          --health-cmd="curl -s http://localhost:8000/shell/ || exit 0"
          --health-interval=5s --health-timeout=2s --health-retries=20

    # for DynamoDB Local
    env:
      AWS_REGION: us-east-1
      DDB_ENDPOINT_URL: http://localhost:8000
      DDB_TABLE: guests-ci-${{ github.run_id }}
      AWS_ACCESS_KEY_ID: localtest
      AWS_SECRET_ACCESS_KEY: localtest

    steps:
      # For manual runs: checkout the branch provided as input
      - name: Checkout (manual)
        if: ${{ github.event_name == 'workflow_dispatch' }}
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.branch }}

      # For push/PR runs: checkout the triggering ref as usual
      - name: Checkout (push/PR)
        if: ${{ github.event_name != 'workflow_dispatch' }}
        uses: actions/checkout@v4

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Setup Python (for small boto3 script)
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install runner-side deps
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Build Docker image (test tag)
        run: |
          docker build -t $DOCKERHUB_USER/$IMAGE_NAME:test .

      - name: Create DynamoDB table (local via boto3)
        run: |
          python - <<'PY'
          import os, time
          import boto3
          region   = os.environ["AWS_REGION"]
          endpoint = os.environ["DDB_ENDPOINT_URL"]
          table    = os.environ["DDB_TABLE"]
          ddb = boto3.client("dynamodb", region_name=region, endpoint_url=endpoint)
          try:
              ddb.create_table(
                  TableName=table,
                  AttributeDefinitions=[{"AttributeName": "seq_num", "AttributeType": "S"}],
                  KeySchema=[{"AttributeName": "seq_num", "KeyType": "HASH"}],
                  BillingMode="PAY_PER_REQUEST",
              )
              print(f"Created table {table}")
          except ddb.exceptions.ResourceInUseException:
              print(f"Table {table} already exists")
          for _ in range(30):
              if ddb.describe_table(TableName=table)["Table"]["TableStatus"] in ("ACTIVE","UPDATING"):
                  break
              time.sleep(0.2)
          print("Table ready.")
          PY

      - name: Install jq
        run: |
          sudo apt-get update
          sudo apt-get install -y jq

      - name: Start API container (wired to local DynamoDB)
        run: |
          docker run -d \
            --name guestlist-test \
            --add-host=host.docker.internal:host-gateway \
            -p 1111:1111 \
            -e AWS_REGION="${AWS_REGION}" \
            -e DDB_TABLE="${DDB_TABLE}" \
            -e DDB_ENDPOINT_URL="http://host.docker.internal:8000" \
            -e AWS_ACCESS_KEY_ID="${AWS_ACCESS_KEY_ID}" \
            -e AWS_SECRET_ACCESS_KEY="${AWS_SECRET_ACCESS_KEY}" \
            $DOCKERHUB_USER/$IMAGE_NAME:test

          echo "Waiting for app to start..."
          for i in {1..40}; do
            curl -fsS http://127.0.0.1:1111/health && break
            sleep 1
          done

          if ! curl -fsS http://127.0.0.1:1111/health >/dev/null; then
            echo "App did not become healthy in time:"
            docker logs guestlist-test
            exit 1
          fi

      - name: Check /api (debug)
        run: curl -fsS http://127.0.0.1:1111/api || true

      - name: Test GET /guests
        run: |
          code=$(curl -s -o /dev/null -w "%{http_code}" http://127.0.0.1:1111/guests)
          if [ "$code" = "200" ]; then
            echo "✓ GET /guests passed"
          else
            echo "✗ GET /guests failed (HTTP $code)"
            docker logs guestlist-test
            exit 1
          fi

      - name: Test POST /guests
        id: post
        run: |
          echo "Testing POST /guests..."
          TEST_ID="111111111"
          resp=$(curl -s -w "\n%{http_code}" -X POST http://127.0.0.1:1111/guests \
            -H "Content-Type: application/json" \
            -d '{
              "firstname": "CI",
              "surname": "Test",
              "quantity": "2",
              "phone": "0541234567",
              "email": "ci@test.com",
              "id": "'${TEST_ID}'"
            }')

          code=$(echo "$resp" | tail -1)
          body=$(echo "$resp" | head -n -1)

          if [ "$code" = "201" ] || [ "$code" = "200" ]; then
            echo "✓ POST /guests passed"
            seq_num=$(echo "$body" | jq -r '.guest.seq_num // empty')
            if [ -z "$seq_num" ] || [ "$seq_num" = "null" ]; then
              echo "Could not parse seq_num from response:"
              echo "$body"
              exit 1
            fi
            echo "seq_num=$seq_num" >> $GITHUB_OUTPUT
          else
            echo "✗ POST /guests failed (HTTP $code)"
            echo "Response: $body"
            docker logs guestlist-test
            exit 1
          fi

      - name: Test GET /guests/{id}
        run: |
          SEQ='${{ steps.post.outputs.seq_num }}'
          code=$(curl -s -o /dev/null -w "%{http_code}" "http://127.0.0.1:1111/guests/$SEQ")
          if [ "$code" = "200" ]; then
            echo "✓ GET /guests/$SEQ passed"
          else
            echo "✗ GET /guests/$SEQ failed (HTTP $code)"
            exit 1
          fi

      - name: Test DELETE /guests/{id}
        run: |
          SEQ='${{ steps.post.outputs.seq_num }}'
          code=$(curl -s -o /dev/null -w "%{http_code}" -X DELETE "http://127.0.0.1:1111/guests/$SEQ")
          if [ "$code" = "200" ] || [ "$code" = "204" ]; then
            echo "✓ DELETE /guests/$SEQ passed"
          else
            echo "✗ DELETE /guests/$SEQ failed (HTTP $code)"
            exit 1
          fi

      - name: Stop test container (always)
        if: always()
        run: |
          docker logs guestlist-test || true
          docker stop guestlist-test || true
          docker rm guestlist-test || true

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ env.DOCKERHUB_USER }}
          password: ${{ env.DOCKERHUB_TOKEN }}

      - name: Compute env tag
        id: envtag
        shell: bash
        run: |
          set -euo pipefail
          branch="${{ github.event_name == 'workflow_dispatch' && inputs.branch || github.ref_name }}"
          sha7="${GITHUB_SHA::7}"

          case "$branch" in
            main)    tag="latest" ;;
            dev)     tag="dev" ;;
            sivan-feature*|dvir-feature*|gili-feature*|sahar-feature*)
              prefix="${branch%%-*}"   # sivan / dvir / gili / sahar
              tag="${prefix}-feature-${sha7}"
              ;;
            *) tag="dev" ;;
          esac

          echo "tag=$tag"   >> "$GITHUB_OUTPUT"
          echo "sha7=$sha7" >> "$GITHUB_OUTPUT"
          echo "Selected tag: $tag (sha7=$sha7)"

      - name: Assert env tag computed
        run: |
          test -n "${{ steps.envtag.outputs.tag }}" || (echo "ERROR: env tag is empty"; exit 1)

      - name: Push image to Docker Hub
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          tags: |
            sivanmonshi/guestlistapi:${{ steps.envtag.outputs.tag }}
            ${{ github.ref_name == 'main' && format('sivanmonshi/guestlistapi:{0}', steps.envtag.outputs.sha7) || '' }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          provenance: mode=max
      
      - name: "Notify Deploy: plan (API push to dev or manual dev)"
        if: >-
          ${{
            (github.event_name == 'push' && github.ref_name == 'dev') ||
            (github.event_name == 'workflow_dispatch' && inputs.branch == 'dev')
          }}
        run: |
          curl -sS -X POST \
            -H "Authorization: token ${{ secrets.REPO_DISPATCH_TOKEN }}" \
            -H "Accept: application/vnd.github+json" \
            https://api.github.com/repos/SivanMon/Guest-List-Deploy/dispatches \
            -d '{"event_type":"deploy_plan","client_payload":{"environment":"dev"}}'

      - name: "Notify Deploy: apply (API PR to main or manual main)"
        if: >-
          ${{
            (github.event_name == 'pull_request' && github.event.pull_request.base.ref == 'main') ||
            (github.event_name == 'workflow_dispatch' && inputs.branch == 'main')
          }}
        run: |
          curl -sS -X POST \
            -H "Authorization: token ${{ secrets.REPO_DISPATCH_TOKEN }}" \
            -H "Accept: application/vnd.github+json" \
            https://api.github.com/repos/SivanMon/Guest-List-Deploy/dispatches \
            -d '{"event_type":"deploy_apply","client_payload":{"environment":"main"}}'
